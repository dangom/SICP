#+TITLE: SICP Solutions - Chapter 1
#+AUTHOR: Daniel Gomez
#+DATE: 25.05.2016


Solution to selected problems from chapter 1. For code only, see sicp1.scm.

* 1.3
#+BEGIN_SRC scheme :exports both :output scalar
(define square (lambda (x) (* x x)))
(define (sos3 a b c)
  (+ (square a) (square b) (square c)))
 ;; should return 50
(sos3 3 4 5)
#+END_SRC

#+RESULTS:
: 50

* 1.4
#+BEGIN_SRC scheme :exports code
(define (a-plus-abs-b a b)
  ((if (> b 0) + -) a b))
#+END_SRC
If b is greater than 0 the expression will evaluate to ~(+ a b)~, otherwise to ~(- a b)~.

* 1.5
#+BEGIN_SRC scheme :exports code :eval never
(define (p) (p))
(define (test x y)
  (if (= x 0)
      0
      y))
(test 0 (p))
#+END_SRC
For an interpreter using applicative evaluation order, the test would never halt. Before
calling the test, (p) would be evaluated to (p), which would in turn be evaluated to
(p), entering an endless loop.
Using normal evaluation order the test would return 0 before ever evaluating (p).

* 1.6
New-if is a standard procedure, and not a special form. Since Scheme uses applicative
order evaluation, all arguments will be evaluated leading to an infinite recursion.

* 1.12
#+BEGIN_SRC scheme :exports both :output scalar
;; Pascal's triangle. Line and column start at 0.
(define (pascal line column)
  (cond ((= column 0) 1)
  ((< line 0) 0)
  ((< column 0) 0)
  ((> column line) 0)
  (else (+ (pascal (- line 1) (- column 1)) (pascal (- line 1) column)))))
;; Should return 6.
(pascal 4 2)
#+END_SRC

#+RESULTS:
: 6

* 1.15
#+BEGIN_SRC scheme :exports both :output scalar
(define (cube x) (* x x x))
(define counter 0)
(define (procsin x)
  (set! counter (+ counter 1)) ;; add this line to see how many times procsin is called.
  (- (* 3 x) (* 4 (cube x))))

(define (sine angle)
  (if (not (> (abs angle) 0.1))
      angle
      (procsin (sine (/ angle 3.0 )))))
(sine 12.15)
;; And the number of times procsin was called is:
counter
#+END_SRC

#+RESULTS:
: 5

* 1.16
#+BEGIN_SRC scheme :exports both :output scalar
(define square (lambda (x) (* x x)))
(define (fast-expt b n)
  (define (fast-expt-iter b n a)
    (cond ((= n 0) a)
    ((even? n) (fast-expt-iter (square b) (/ n 2) a))
    (else (fast-expt-iter b (- n 1) (* a b)))))
  (fast-expt-iter b n 1))

(fast-expt 2 10)
#+END_SRC

#+RESULTS:
: 1024

* 1.17
#+BEGIN_SRC scheme :exports both :output scalar
(define (my* a b)
  (if (= b 0)
      0
      (+ a (my* a (- b 1)))))

(define (mymult a b)
  (define (double a)
    (+ a a))
  (define (halve b)
    (/ b 2))
  (cond ((= b 0) 0)
        ((even? b) (mymult (double a) (halve b)))
        (else (+ a (mymult a (- b 1))))))
;; Expects 56
(mymult 7 8)
#+END_SRC

#+RESULTS:
: 56

* 1.18
The solution here is to change the multiplier(x) and multiplicand(y) so as
to reduce the problem to the multiplication of (x*y)*1. We can achieve
this by simultaneously halving the multiplicand and doubling the multiplier
if the multiplicand is even. If odd, we add to the result decrementing the multiplicand.
Here, the result is only incremented when the the multiplier is odd.
#+BEGIN_SRC scheme :exports both :output scalar
(define (mymult multiplier multiplicand)
  (define (double a)
    (+ a a))
  (define (halve b)
    (/ b 2))
  (define (mymult-iter x y a)
    (cond ((= y 0) a)
          ((even? y) (mymult-iter (double x) (halve y) a))
          (else (mymult-iter x (- y 1) (+ a x)))))
  (mymult-iter multiplier multiplicand 0))

;;Expects 56
(mymult 7 8)
#+END_SRC

#+RESULTS:
: 56

* 1.19
#+BEGIN_SRC scheme :exports both :output scalar
(define (fib n)
  (define (fib-iter a b p q count)
    (cond ((= count 0) b)
          ((even? count)
           (fib-iter a
                     b
                     (+ (* p p) (* q q))
                     (+ ( * 2 p q) (* q q))
                     (/ count 2)))
          (else (fib-iter (+ (* b p) (* a q) (* a p))
                          (+ (* b p) (* a q))
                          p
                          q
                          (- count 1)))))
  (fib-iter 1 0 0 1 n))

;; Expects 11765046532
(fib 50)
#+END_SRC

#+RESULTS:
: 11765046532





